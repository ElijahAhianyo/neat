# Neat Utils

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
None
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-neat.utils.make_colorwheel-start--->
## [neat.utils.make_colorwheel](4-neat_utils.md#neat.utils.make_colorwheel)

<!---Documatic-section-make_colorwheel-start--->
<!---Documatic-block-neat.utils.make_colorwheel-start--->
<details>
	<summary><code>neat.utils.make_colorwheel</code> code snippet</summary>

```python
def make_colorwheel():
    RY = 15
    YG = 6
    GC = 4
    CB = 11
    BM = 13
    MR = 6
    ncols = RY + YG + GC + CB + BM + MR
    colorwheel = np.zeros((ncols, 3))
    col = 0
    colorwheel[0:RY, 0] = 255
    colorwheel[0:RY, 1] = np.floor(255 * np.arange(0, RY) / RY)
    col = col + RY
    colorwheel[col:col + YG, 0] = 255 - np.floor(255 * np.arange(0, YG) / YG)
    colorwheel[col:col + YG, 1] = 255
    col = col + YG
    colorwheel[col:col + GC, 1] = 255
    colorwheel[col:col + GC, 2] = np.floor(255 * np.arange(0, GC) / GC)
    col = col + GC
    colorwheel[col:col + CB, 1] = 255 - np.floor(255 * np.arange(CB) / CB)
    colorwheel[col:col + CB, 2] = 255
    col = col + CB
    colorwheel[col:col + BM, 2] = 255
    colorwheel[col:col + BM, 0] = np.floor(255 * np.arange(0, BM) / BM)
    col = col + BM
    colorwheel[col:col + MR, 2] = 255 - np.floor(255 * np.arange(MR) / MR)
    colorwheel[col:col + MR, 0] = 255
    return colorwheel
```
</details>
<!---Documatic-block-neat.utils.make_colorwheel-end--->
<!---Documatic-section-make_colorwheel-end--->

# #
<!---Documatic-section-neat.utils.make_colorwheel-end--->

<!---Documatic-section-neat.utils.flow_uv_to_colors-start--->
## [neat.utils.flow_uv_to_colors](4-neat_utils.md#neat.utils.flow_uv_to_colors)

<!---Documatic-section-flow_uv_to_colors-start--->
```mermaid
flowchart LR
neat.utils.flow_uv_to_colors-->neat.utils.make_colorwheel
```

### Object Calls

* [neat.utils.make_colorwheel](4-neat_utils.md#neat.utils.make_colorwheel)

<!---Documatic-block-neat.utils.flow_uv_to_colors-start--->
<details>
	<summary><code>neat.utils.flow_uv_to_colors</code> code snippet</summary>

```python
def flow_uv_to_colors(u, v, convert_to_bgr=False):
    flow_image = np.zeros((u.shape[0], u.shape[1], 3), np.uint8)
    colorwheel = make_colorwheel()
    ncols = colorwheel.shape[0]
    rad = np.sqrt(np.square(u) + np.square(v))
    a = np.arctan2(-v, -u) / np.pi
    fk = (a + 1) / 2 * (ncols - 1)
    k0 = np.floor(fk).astype(np.int32)
    k1 = k0 + 1
    k1[k1 == ncols] = 0
    f = fk - k0
    for i in range(colorwheel.shape[1]):
        tmp = colorwheel[:, i]
        col0 = tmp[k0] / 255.0
        col1 = tmp[k1] / 255.0
        col = (1 - f) * col0 + f * col1
        idx = rad <= 1
        col[idx] = 1 - rad[idx] * (1 - col[idx])
        col[~idx] = col[~idx] * 0.75
        ch_idx = 2 - i if convert_to_bgr else i
        flow_image[:, :, ch_idx] = np.floor(255 * col)
    return flow_image
```
</details>
<!---Documatic-block-neat.utils.flow_uv_to_colors-end--->
<!---Documatic-section-flow_uv_to_colors-end--->

# #
<!---Documatic-section-neat.utils.flow_uv_to_colors-end--->

<!---Documatic-section-neat.utils.flow_to_color-start--->
## [neat.utils.flow_to_color](4-neat_utils.md#neat.utils.flow_to_color)

<!---Documatic-section-flow_to_color-start--->
```mermaid
flowchart LR
neat.utils.flow_to_color-->neat.utils.flow_uv_to_colors
neat.utils.flow_uv_to_colors-->neat.utils.make_colorwheel
```

### Object Calls

* [neat.utils.flow_uv_to_colors](4-neat_utils.md#neat.utils.flow_uv_to_colors)

<!---Documatic-block-neat.utils.flow_to_color-start--->
<details>
	<summary><code>neat.utils.flow_to_color</code> code snippet</summary>

```python
def flow_to_color(flow_uv, clip_flow=None, convert_to_bgr=False):
    assert flow_uv.ndim == 3, 'input flow must have three dimensions'
    assert flow_uv.shape[2] == 2, 'input flow must have shape [H,W,2]'
    if clip_flow is not None:
        flow_uv = np.clip(flow_uv, 0, clip_flow)
    u = flow_uv[:, :, 0]
    v = flow_uv[:, :, 1]
    rad = np.sqrt(np.square(u) + np.square(v))
    rad_max = np.max(rad)
    epsilon = 1e-05
    u = u / (rad_max + epsilon)
    v = v / (rad_max + epsilon)
    return flow_uv_to_colors(u, v, convert_to_bgr)
```
</details>
<!---Documatic-block-neat.utils.flow_to_color-end--->
<!---Documatic-section-flow_to_color-end--->

# #
<!---Documatic-section-neat.utils.flow_to_color-end--->

<!---Documatic-section-neat.utils.iou-start--->
## [neat.utils.iou](4-neat_utils.md#neat.utils.iou)

<!---Documatic-section-iou-start--->
<!---Documatic-block-neat.utils.iou-start--->
<details>
	<summary><code>neat.utils.iou</code> code snippet</summary>

```python
def iou(points1: torch.Tensor, points2: torch.Tensor):
    points1 = points1.view(-1).byte()
    points2 = points2.view(-1).byte()
    assert points1.shape == points2.shape, 'points1 and points2 must have the same shape'
    intersection = torch.sum(torch.mul(points1, points2).float())
    union = torch.sum((points1 + points2).clamp(min=0, max=1).float())
    return (intersection, union)
```
</details>
<!---Documatic-block-neat.utils.iou-end--->
<!---Documatic-section-iou-end--->

# #
<!---Documatic-section-neat.utils.iou-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)